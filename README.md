# VFormula
Math expression parser and thead-safe evaluator 

## Description
VFormula was concieved as a lightweight and therad-safe replacement for the [TFormula](https://root.cern.ch/doc/v636/classTFormula.html) class from CERN [ROOT](https://root.cern.ch) data analysis package. The parser compiles a provided C-style math expression into an RPN bytecode that can be executed by a simple stack machine. The performance of the stack machine can be significantly improved by using vector variables from [Eigen](https://libeigen.gitlab.io/) library. 

### Input expression
The expression parser is case-sensitive, spaces are ignored. There are three types of operands: variable, parameter (named constant) and number. The naming of the operands follows the standard C rules. Variables and parameters are alpha-numeric, begin with a letter and may contain an underscore. Numbers start with a digit or a minus sign and can be in either normal (`1234.56`) or exponential (`1.23456e3`) notation. 

Operators, in order of increasing precedence, are:

* addition(\+) and subtraction (-)
* multiplication (\*) and division (/)
* power (^)

Multiple levels of parentheses can be used to override the default precedence.

Functions can be taken of sub-expressions in parentheses, as for example `sin(x*2+1)`. The following functions of one variable from standard cmath library are available by default:

* `abs()`, `sqrt()`, `exp()`, `log()`
* `sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()`
* `sinh()`, `cosh()`, `tanh()`, `asinh()`, `acosh()`, `atanh()`

There is also a couple of functions of two variables available: `min()` and `max()`. A comma is used to separate the operands in such functions, e.g. `min(1,exp(-x))`

A complex expression can be subdivided into semicolon-separated subexpressions with intermediate results assigned to temporary variables using equals (=) operator. The evaluation will return the result of the last (rightmost) subexpression. For example to efficiently evaluate sinc(sqrt(x^2+y^2)), write `r=sqrt(x^2+y^2);sin(r)/r`

### Usage
Instantiate a VFormula object indicating the variable type for the stack machine. You can use one of C++ scalar types or one of Eigen vector types here. Before running the parser, define parameters and declare variables that can be used in the expression. 

``` cpp
VFormula <double> vf;
vf.AddConstant("pi", M_PI); // define parameter pi=3.1415...
vf.AddVariable("x");        // declare variable name
```
Parse the expression. The parser returns 1024 on successful completion or approximate position of the error otherwise. Then run validator to check the generated bytecode for consistency. If both parser and validator gave no error, call `Eval()` to evaluate the expression. 
```cpp
std::string f("sin(pi*x)"); // expression to parse
int errpos = vf.ParseExpr(f);
if (errpos != 1024) {
    std::cout << "Parsing error " << vf.GetErrorString().c_str() << " at " << errpos << std::endl;
    ......
}
if (!vf.Validate()) {
    std::cout << "Validation failed: " << vf.GetErrorString().c_str() << std::endl;
    ......
}
......
b = vf.Eval(a);
```

### Examples
The scalar and vector examples are in `tests` and `vectests` folders, respectively. Run `make tests` or `make vectests` to get them built. The binaries will be placed in the `bin` folder. Note that in order to compile the vector tests, you need [Eigen](https://libeigen.gitlab.io/) library installed.

